#ifndef VS_OBJECTARRAY_H
#define VS_OBJECTARRAY_H

namespace vs {

template<typename Type> // 模板声明
class VsObjectArray {

    public:
        VsObjectArray();
        VsObjectArray(int volume);
        ~VsObjectArray();

        void init(int volume);
        void put(Type *p);

        int getLength();
        int getVolume();

    private:
        Type **p;    //类型数组
        int volume; //现有的容量
        int length; //现有元素的个数
};

template<typename Type> // 模板声明
VsObjectArray<Type>::VsObjectArray()
{
    this->init(10);
}

template<typename Type> // 模板声明
VsObjectArray<Type>::VsObjectArray(int volume)
{
    this->init(volume);
}

template<typename Type>
void VsObjectArray<Type>::init(int volume)
{
    this->volume = volume;
    //指针数组
    this->p = (Type **)malloc(sizeof(Type *)*this->volume);
    this->length = 0;
}

template<typename Type> // 模板声明
VsObjectArray<Type>::~VsObjectArray()
{
    for(int i = 0; i < this->length; i++)
    {
        delete *(this->p + i);
    }
    printf("destroy------------\n");
    free(this->p);
}

template<typename Type>
void VsObjectArray<Type>::put(Type *pObj)
{
    //容量不够，需要扩充容量
    if(this->length >= this->volume)
    {
        //扩展的容量方式为，自身容量+自身容量*1/3，最小扩充3
        int add = this->volume/3;
        if(add < 3)
        {
            add = 3;
        }
        int newVolume = this->volume + add;
        Type** newP = (Type **)realloc(this->p, newVolume);
        if(newP != NULL)
        {
            this->p = newP;
            this->volume = newVolume;
        }
    }
    *(this->p + this->length) = pObj;
    this->length++;
}

template<typename Type>
int VsObjectArray<Type>::getLength()
{
    return this->length;
}

template<typename Type>
int VsObjectArray<Type>::getVolume()
{
    return this->volume;
}

}

#endif