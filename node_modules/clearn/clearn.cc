#include <stdio.h>
#include <stdlib.h>

#include <node.h>
#include <v8.h>

#include "StringUtil.h"
#include "String.h"

using namespace v8;

/**
 * 普通变量有两层含义(自己的地址，自己的值)
 * 获取变量的地址，指针变量有3层含义(自己的地址，自己的值，自己所指向的地址的值)
 */
Handle<Value> varAddr(const Arguments& args)
{
    HandleScope scope;
    int val = 10;
    int *p = &val;
    int y = *p;
    int z = *p;
    printf("变量val的地址:%ld\n", (long)p);
    printf("变量y的地址:%ld\n", (long)&y);
    printf("变量z的地址:%ld\n", (long)&z);
    printf("指针变量p的地址:%ld\n", (long)&p);
    printf("指针变量p指向的地址:%ld\n", (long)p);
    printf("变量的值:%d\n", *p);
    Handle<Array> array = Array::New();
    return scope.Close(array);
}

/**
 * 指针在未初始化时，指向的地址是0
 * 数组的a[10]，声明之后，a其实是个指针，其值是元素a[0]的地址。
 */
Handle<Value> arrayAddr(const Arguments& args)
{
    HandleScope scope;
    int a[10], *p = 0;  //指针在初始化时，给的是自己的值，而非指向的地址对应的值
    printf("空指针指向的地址:%ld\n", (long)p);
    printf("数组a的地址:%ld\n", (long)a);
    printf("数组a首元素的地址:%ld\n", (long)&(a[0]));
    Handle<Array> array = Array::New();
    return scope.Close(array);
}

struct student_node {
    char name[20];
    struct student_node* next;
};

/**
 * 关于结构体的大小，结构体的大小以其最宽的基本数据类型为基准，
 * 从结构体中数据分配的顺序依次分配空间，空间不足时，再重新申请一个基准的空间
 */
Handle<Value> structAddr(const Arguments& args)
{
    HandleScope scope;
    printf("结构体的大小:%ld\n", sizeof(student_node));

    student_node* head = (student_node*)malloc(sizeof(student_node));
    const char* pName = "liming";
    StringUtil::Copy(pName, head->name);
    printf("%s\n", head->name);
    free(head);

    Handle<Array> array = Array::New();
    return scope.Close(array);
}

/**
 * 关于结构体的大小，结构体的大小以其最宽的基本数据类型为基准，
 * 从结构体中数据分配的顺序依次分配空间，空间不足时，再重新申请一个基准的空间
 */
Handle<Value> stringTest(const Arguments& args)
{
    HandleScope scope;

    vs::String* str = new vs::String(20, "黎明");
    str->show();
    printf("大小:%d\n", str->getLength());
    printf("容量:%d\n", str->getVolume());
    str->append(",hello world!");
    str->show();
    printf("大小:%d\n", str->getLength());
    printf("容量:%d\n", str->getVolume());

    vs::String* str1 = new vs::String(20, ",welcome!");
    str1->show();

    str->append(str1);
    str->append(",lm....", 4);
    str->show();
    printf("大小:%d\n", str->getLength());
    printf("容量:%d\n", str->getVolume());

    str->split(',');

    delete str;
    delete str1;

    printf("%d\n", StringUtil::Length("黎明"));

    Handle<Array> array = Array::New();
    return scope.Close(array);
}

Handle<Value> Method(const Arguments& args) {
  HandleScope scope;
  return scope.Close(String::New("world"));
}

void init(Handle<Object> exports) {
    exports->Set(String::NewSymbol("hello"), FunctionTemplate::New(Method)->GetFunction());
    exports->Set(String::NewSymbol("varAddr"), FunctionTemplate::New(varAddr)->GetFunction());
    exports->Set(String::NewSymbol("arrayAddr"), FunctionTemplate::New(arrayAddr)->GetFunction());
    exports->Set(String::NewSymbol("structAddr"), FunctionTemplate::New(structAddr)->GetFunction());
    exports->Set(String::NewSymbol("stringTest"), FunctionTemplate::New(stringTest)->GetFunction());
}

NODE_MODULE(clearn, init)
